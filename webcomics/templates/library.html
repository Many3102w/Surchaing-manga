{% extends "./layouts/base.html" %}
{% load static %}

{% block title %}Catálogo{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href='{% static "css/home_redesign.css" %}'>
<style>
    .feed-container {
        max-width: 600px;
        margin: 0 auto;
        padding: 20px;
    }

    .feed-header-actions {
        display: flex;
        justify-content: flex-end;
        margin-bottom: 25px;
    }

    .btn-create-post {
        background: #111;
        color: #fff;
        padding: 12px 24px;
        border-radius: 6px;
        text-decoration: none;
        text-transform: uppercase;
        font-size: 0.8rem;
        font-weight: 800;
        display: inline-flex;
        align-items: center;
        gap: 10px;
        border: 1px solid #111;
        transition: 0.25s;
    }

    .btn-create-post:hover {
        background: transparent;
        color: #111;
        transform: translateY(-2px);
    }

    .feed-card {
        background: #fff;
        border: 1px solid #eee;
        margin-bottom: 60px;
        box-shadow: 0 15px 45px rgba(0, 0, 0, 0.07);
        border-radius: 8px;
        position: relative;
        overflow: hidden;
    }

    .feed-card-header {
        padding: 15px 20px;
        display: flex;
        align-items: center;
        border-bottom: 1px solid #f8f8f8;
    }

    .feed-avatar {
        width: 38px;
        height: 38px;
        border-radius: 50%;
        background: #111 url('{% static "images/logo/logo_v2.png" %}') center/cover;
        margin-right: 15px;
        border: 1px solid #eee;
    }

    .feed-username {
        font-weight: 700;
        font-size: 0.95rem;
        color: #111;
    }

    .dropdown {
        position: relative;
        margin-left: auto;
    }

    .dropdown-content {
        display: none;
        position: absolute;
        right: 0;
        top: 30px;
        background: #fff;
        min-width: 140px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        z-index: 100;
        border-radius: 6px;
    }

    .dropdown-content a {
        color: #333;
        padding: 12px 18px;
        text-decoration: none;
        display: block;
        font-size: 0.9rem;
    }

    .dropdown-content a:hover {
        background: #f5f5f5;
    }

    .dropdown:hover .dropdown-content {
        display: block;
    }

    .feed-image-container {
        width: 100%;
        aspect-ratio: 1/1;
        background: #f9f9f9;
        position: relative;
        overflow: hidden;
        cursor: zoom-in;
    }

    .has-3d .feed-image {
        opacity: 0;
        pointer-events: none;
    }

    .feed-image {
        transition: opacity 0.5s ease;
        width: 100%;
        height: 100%;
        object-fit: contain;
        /* Better fit for all formats */
        transition: opacity 0.5s;
    }

    .depth-3d-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: none;
        z-index: 5;
    }

    .has-3d .depth-3d-canvas {
        display: block;
    }

    .manga-3d-badge {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        padding: 6px 14px;
        border-radius: 30px;
        font-size: 0.65rem;
        font-weight: 900;
        z-index: 10;
        border: 1px solid rgba(255, 255, 255, 0.2);
        pointer-events: none;
        backdrop-filter: blur(8px);
    }

    .manga-size-badge {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background: rgba(255, 255, 255, 0.9);
        color: #000;
        padding: 4px 10px;
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: 800;
        z-index: 10;
        border: 1px solid rgba(0, 0, 0, 0.1);
        pointer-events: none;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        text-transform: uppercase;
    }

    .feed-actions {
        padding: 18px 20px;
        display: flex;
        gap: 24px;
        font-size: 1.6rem;
        color: #1a1a1a;
    }

    .action-btn {
        background: none;
        border: none;
        cursor: pointer;
        color: inherit;
        transition: 0.2s;
    }

    .liked {
        color: #ff3040 !important;
    }

    .feed-caption {
        padding: 0 20px 20px 20px;
        font-size: 1rem;
        line-height: 1.5;
    }

    .price-tag {
        color: #bfa37c;
        font-weight: 900;
        float: right;
        font-size: 1.2rem;
    }

    .comment-form {
        display: flex;
        padding: 15px 20px;
        border-top: 1px solid #f5f5f5;
        background: #fafafa;
    }

    .comment-form input {
        flex: 1;
        border: 1px solid #e0e0e0;
        padding: 10px 15px;
        border-radius: 30px;
        margin-right: 12px;
        font-size: 0.9rem;
    }

    .comment-form button {
        border: none;
        background: none;
        color: #0095f6;
        font-weight: 800;
        cursor: pointer;
    }

    /* Zoom Modal Styles */
    #zoom-modal {
        display: none;
        position: fixed;
        z-index: 9999;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        align-items: center;
        justify-content: center;
        cursor: zoom-out;
    }

    #zoom-modal img {
        max-width: 90%;
        max-height: 90%;
        box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        border-radius: 4px;
        transform: scale(0.9);
        transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    #zoom-modal.active {
        display: flex;
    }

    #zoom-modal.active img {
        transform: scale(1);
    }
</style>
{% endblock %}

{% block content %}
<div class="concept-container">
    <div class="concept-hero" style="min-height: 25vh; padding-top: 140px; margin-bottom: 40px;">
        <h1 style="font-size: 5rem; letter-spacing: -3px; margin:0;">CATÁLOGO</h1>
    </div>

    <div class="feed-container">
        {% if user.is_superuser %}
        <div class="feed-header-actions">
            <a href="{% url 'create_post' %}" class="btn-create-post"><i class="bi bi-plus-circle"></i> NUEVA
                PUBLICACIÓN</a>
        </div>
        {% endif %}

        {% for manga in recent_mangas %}
        <div class="feed-card" id="manga-{{ manga.id }}">
            <div class="feed-card-header">
                <div class="feed-avatar"></div>
                <div class="feed-username">{% if manga.publicado_por %}{{ manga.publicado_por }}{% else %}Surchaing
                    Manga{% endif %}</div>
                {% if user.is_superuser %}
                <div class="dropdown">
                    <div style="cursor: pointer; padding: 5px;"><i class="bi bi-three-dots-vertical"></i></div>
                    <div class="dropdown-content">
                        <a href="{% url 'vendido_toggle' manga_id=manga.id %}">
                            {% if manga.vendido %}Marcar Disponible{% else %}Marcar Vendido{% endif %}
                        </a>
                        <a href="{% url 'delete_post' manga.id %}" style="color:#f00">Eliminar</a>
                    </div>
                </div>
                {% endif %}
            </div>

            <div class="feed-image-container"
                data-front="{% if manga.front_page %}{{ manga.front_page.url }}{% endif %}"
                data-depth="{% if manga.depth_map %}{{ manga.depth_map.url }}{% endif %}"
                data-mesh="{% if manga.mesh_3d %}{{ manga.mesh_3d.url }}{% endif %}" data-manga-id="{{ manga.id }}"
                onclick="{% if manga.front_page %}openZoom('{{ manga.front_page.url }}'){% endif %}">

                {% if manga.vendido %}
                <div class="sold-badge"
                    style="position: absolute; top: 10px; right: 10px; background: #ff4d4d; color: #fff; padding: 5px 12px; border-radius: 20px; font-weight: 800; font-size: 0.75rem; z-index: 100; box-shadow: 0 4px 10px rgba(255,77,77,0.4); text-transform: uppercase; letter-spacing: 1px;">
                    VENDIDO</div>
                {% endif %}

                {% if manga.is_3d_converted and manga.front_page and manga.depth_map %}
                <div class="manga-3d-badge"><i class="bi bi-robot"></i> IA 3D ANALYSIS</div>
                <canvas class="depth-3d-canvas"></canvas>
                {% endif %}

                {% if manga.images.count > 0 %}
                <div class="gallery-count-badge"
                    style="position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.6); color: #fff; padding: 2px 8px; border-radius: 4px; font-size: 0.7rem; z-index: 10; display: flex; align-items: center; gap: 4px;">
                    <i class="bi bi-images"></i> +{{ manga.images.count }}
                </div>
                {% endif %}

                {% if manga.talla %}
                <div class="manga-size-badge">Talla: {{ manga.talla }}</div>
                {% endif %}

                {% if manga.front_page %}
                <img src="{{ manga.front_page.url }}" class="feed-image" alt="{{ manga.nombre_del_manga }}">
                {% else %}
                <div class="no-image-placeholder"
                    style="width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:#f5f5f5; color:#ccc;">
                    <div style="text-align: center;">
                        <i class="bi bi-image" style="font-size: 3rem;"></i>
                        <p style="font-size: 0.8rem; margin-top: 5px;">Sin imagen</p>
                    </div>
                </div>
                {% endif %}
            </div>

            <div class="feed-actions">
                <button class="action-btn" onclick="toggleLike('{{ manga.id }}')">
                    <i id="like-icon-{{ manga.id }}"
                        class="bi bi-heart{% if request.user in manga.likes.all %}-fill liked{% endif %}"></i>
                </button>
                <span id="like-count-{{ manga.id }}"
                    style="font-size: 1.1rem; font-weight: bold; margin-left: -15px;">{{ manga.likes.count }}</span>
                <button class="action-btn"><i class="bi bi-chat-left-text"></i></button>
                <div style="margin-left: auto;"><i class="bi bi-bookmark-star"></i></div>
            </div>

            <div class="feed-caption">
                <span class="price-tag">${{ manga.precio }}</span>
                <strong>{{ manga.nombre_del_manga }}</strong>
                <p style="color: #666; margin-top: 5px; margin-bottom: 15px;">
                    {% if manga.descripcion %}{{ manga.descripcion }}{% else %}Surchaing Premium Edition.{% endif %}
                </p>

                <!-- Lista de Comentarios -->
                <div class="feed-comments-list"
                    style="font-size: 0.9rem; border-top: 1px solid #f0f0f0; padding-top: 10px;">
                    {% for comment in manga.comments.all %}
                    <div class="comment-item" style="margin-bottom: 5px;">
                        <strong>{% if comment.user %}{{ comment.user.username }}{% else %}Anónimo{% endif %}:</strong>
                        {{ comment.text }}
                    </div>
                    {% empty %}
                    <p style="color: #999; font-style: italic; font-size: 0.85rem;">Sé el primero en comentar...</p>
                    {% endfor %}
                </div>
            </div>

            <form class="comment-form" action="{% url 'add_comment' manga.id %}" method="post">
                {% csrf_token %}
                <input type="text" name="text" id="comment-input-{{ manga.id }}" placeholder="Añade un comentario..."
                    required>
                <button type="submit">Publicar</button>
            </form>
        </div>
        {% endfor %}
    </div>
</div>

<!-- Zoom Modal -->
<div id="zoom-modal" onclick="closeZoom()">
    <img id="zoom-img" src="" alt="Zoomed View">
</div>

{% endblock %}

{% block extra_js %}
<script type="module">
    // Import Transformers.js from CDN (Direct Web AI)
    // Updated to v2.17.2 to support 'depth-anything' models
    import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2';

    // Skip local model checks to avoid 404s on checking for 'local' files
    env.allowLocalModels = false;
    env.useBrowserCache = true;

    // Singleton for the depth model
    let depthEstimator = null;

    async function ensureModel() {
        if (!depthEstimator) {
            console.log("Loading Client-Side AI Model...");
            // Use a small, fast quantization model properly cached in browser
            depthEstimator = await pipeline('depth-estimation', 'Xenova/depth-anything-small-hf');
        }
        return depthEstimator;
    }

    // Expose generation function globally for the 3D viewer
    window.generateClientSideDepth = async (imageUrl, container) => {
        try {
            const estimator = await ensureModel();
            console.log("Generating Depth on Client...", imageUrl);

            // Run inference
            const result = await estimator(imageUrl);
            // result is usually { depth: Tensor, predicted_depth: Tensor } 
            // Transformers.js depth-estimation pipeline returns a raw object with a `depth` property that is a Greyscale Image (Tensor-like)
            // Actually, the pipeline returns { depth: RawImage }

            if (result && result.depth) {
                // Convert to Canvas/DataURL
                const canvas = document.createElement('canvas');
                canvas.width = result.depth.width;
                canvas.height = result.depth.height;
                const ctx = canvas.getContext('2d');

                // FIXED: Convert output (likely grayscale/RGB) to RGBA for ImageData configuration
                const rawData = result.depth.data; // Uint8Array or Float32Array
                const width = result.depth.width;
                const height = result.depth.height;
                const channels = result.depth.channels || 1; // Usually 1 for depth

                // Create strict RGBA buffer (4 channels)
                const rgbaData = new Uint8ClampedArray(width * height * 4);

                for (let i = 0; i < width * height; i++) {
                    const val = rawData[i * channels]; // Get pixel value
                    // Set R, G, B to the value (Grayscale)
                    rgbaData[i * 4] = val;     // R
                    rgbaData[i * 4 + 1] = val; // G
                    rgbaData[i * 4 + 2] = val; // B
                    rgbaData[i * 4 + 3] = 255; // Alpha (Opaque)
                }

                const imageData = new ImageData(rgbaData, width, height);
                ctx.putImageData(imageData, 0, 0);

                const dataUrl = canvas.toDataURL('image/png');
                console.log("Client-Side Depth Generated!");

                // Inject into container and restart viewer
                container.dataset.depth = dataUrl;

                // Add the 3D Badge explicitly since we forced it
                if (!container.querySelector('.manga-3d-badge')) {
                    const badge = document.createElement('div');
                    badge.className = 'manga-3d-badge';
                    badge.innerHTML = '<i class="bi bi-cpu"></i> WEB AI 3D';
                    container.appendChild(badge);

                    const canvas3d = document.createElement('canvas');
                    canvas3d.className = 'depth-3d-canvas';
                    container.appendChild(canvas3d);
                }

                // Trigger global init if defined
                if (window.initApp3D) window.initApp3D(container);
            }
        } catch (e) {
            console.error("Client AI Error:", e);
        }
    };

    // Auto-scan for items missing depth maps
    // OPTIMIZATION: Only check the LATEST (First) post to avoid freezing the browser with multiple AI runs
    window.checkMissingDepth = () => {
        const container = document.querySelector('.feed-image-container'); // Selects only the first one
        if (container) {
            const front = container.dataset.front;
            const depth = container.dataset.depth;
            // If we have an image but NO depth map, try to generate it client-side
            if (front && (!depth || depth === "")) {
                console.log("Checking latest post for 3D...");
                window.generateClientSideDepth(front, container);
            }
        }
    };

    // Run check on load
    if (document.readyState === 'complete') window.checkMissingDepth();
    else window.addEventListener('load', window.checkMissingDepth);

</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script>
    const modal = document.getElementById('zoom-modal');
    const zoomImg = document.getElementById('zoom-img');

    function openZoom(url) {
        zoomImg.src = url;
        modal.classList.add('active');
    }

    function closeZoom() {
        modal.classList.remove('active');
    }

    const activeViewers = new Map();

    function initPerfect3D() {
        const containers = document.querySelectorAll('.feed-image-container');

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    createViewer(entry.target);
                } else {
                    disposeViewer(entry.target);
                }
            });
        }, { threshold: 0.05, rootMargin: '200px' });

        containers.forEach(container => {
            // Updated: Observe ALL containers, not just ones with existing canvases.
            // Why? Because Client-Side AI might add the canvas later.
            observer.observe(container);
        });

        window.addEventListener('resize', () => {
            activeViewers.forEach(viewer => viewer.updateSize());
        });
    }

    // Expose specifically for the Module script to call
    window.initApp3D = (singleContainer) => {
        createViewer(singleContainer);
    };

    function createViewer(container) {
        if (activeViewers.has(container)) return;

        // Check again for canvas (client AI might have added it)
        let canvas = container.querySelector('.depth-3d-canvas');
        if (!canvas) return; // Still no 3D available

        const meshUrl = container.dataset.mesh;
        const frontUrl = container.dataset.front;
        const depthUrl = container.dataset.depth; // This might be a Data URL now!

        if (!frontUrl || !depthUrl) return;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(35, 1, 0.1, 1000);
        camera.position.z = 6.5;

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const updateSize = () => {
            const r = container.getBoundingClientRect();
            renderer.setSize(r.width, r.height);
            camera.updateProjectionMatrix();
        };
        updateSize();

        scene.add(new THREE.AmbientLight(0xffffff, 1.0));
        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(2, 2, 5);
        scene.add(light);

        const viewer = {
            renderer, scene, camera, updateSize, container,
            animateId: null, isDisposed: false, targetX: 0, targetY: 0
        };
        activeViewers.set(container, viewer);

        viewer.onMouseMove = (e) => {
            const r = container.getBoundingClientRect();
            viewer.targetX = ((e.clientX - r.left) / r.width) * 2 - 1;
            viewer.targetY = -(((e.clientY - r.top) / r.height) * 2 - 1);
        };
        container.addEventListener('mousemove', viewer.onMouseMove);

        if (meshUrl && meshUrl !== "") {
            const glbLoader = new THREE.GLTFLoader();
            glbLoader.load(meshUrl, (gltf) => {
                if (viewer.isDisposed) return;
                const model = gltf.scene;
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3()).length();
                const center = box.getCenter(new THREE.Vector3());
                model.position.sub(center);
                model.scale.setScalar(2.0 / size);
                scene.add(model);

                canvas.style.display = 'block';
                startAnimate(viewer, model, null);

                // Show Badge if hidden (e.g. Server generated mesh but depth failed)
                container.classList.add('has-3d');

            }, undefined, (err) => {
                console.warn("Fallback displacement", err);
                loadDisplacement(viewer);
            });
        } else {
            loadDisplacement(viewer);
        }
    }

    async function loadDisplacement(viewer) {
        const { container, scene, camera, renderer } = viewer;
        const frontUrl = container.dataset.front;
        const depthUrl = container.dataset.depth;

        if (!frontUrl || !depthUrl || viewer.isDisposed) return;

        const loader = new THREE.TextureLoader();
        // Allow Data URLs cross origin (safe for data urls)
        loader.crossOrigin = 'Anonymous';

        const loadP = (url) => new Promise((res, rej) => loader.load(url, res, undefined, rej));

        try {
            const [tex, dTex] = await Promise.all([loadP(frontUrl), loadP(depthUrl)]);
            if (viewer.isDisposed) {
                tex.dispose(); dTex.dispose();
                return;
            }

            const geometry = new THREE.PlaneGeometry(2, 2, 128, 128);
            const material = new THREE.ShaderMaterial({
                uniforms: { uTex: { value: tex }, uDepth: { value: dTex }, uTime: { value: 0 } },
                transparent: true, side: THREE.DoubleSide,
                vertexShader: `
                    varying vec2 vUv;
                    varying float vDepth;
                    varying float vMask;
                    uniform sampler2D uDepth;
                    void main() {
                        vUv = uv;
                        float d = texture2D(uDepth, uv).r;
                        vDepth = d;
                        float mask = smoothstep(0.0, 0.02, uv.x) * smoothstep(1.0, 0.98, uv.x) * 
                                     smoothstep(0.0, 0.02, uv.y) * smoothstep(1.0, 0.98, uv.y);
                        vMask = mask;
                        vec3 pos = position;
                        pos.z += d * 1.2 * mask; 
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv;
                    varying float vDepth;
                    varying float vMask;
                    uniform sampler2D uTex;
                    uniform sampler2D uDepth;
                    void main() {
                        vec4 color = texture2D(uTex, vUv);
                        float isBG = (1.0 - smoothstep(0.0, 0.05, vDepth)) * smoothstep(2.8, 3.0, color.r + color.g + color.b);
                        float alpha = (1.0 - isBG) * vMask;
                        if (alpha < 0.1) discard;
                        float ps = 0.002;
                        float dR = texture2D(uDepth, vUv + vec2(ps, 0.0)).r;
                        float dD = texture2D(uDepth, vUv + vec2(0.0, ps)).r;
                        vec3 normal = normalize(vec3((vDepth - dR)*5.0, (vDepth - dD)*5.0, 0.5));
                        if (normal.z < 0.2) discard;
                        vec3 lightDir = normalize(vec3(-0.8, 0.5, 0.8)); 
                        float diff = max(dot(normal, lightDir), 0.0);
                        vec3 final = mix(color.rgb * 0.6, color.rgb * 1.2, diff) * smoothstep(0.0, 0.3, vDepth);
                        gl_FragColor = vec4(final, alpha);
                    }
                `
            });

            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            // Sombra
            const sMat = material.clone();
            sMat.fragmentShader = `
                varying vec2 vUv; varying float vDepth; varying float vMask;
                uniform sampler2D uTex; uniform sampler2D uDepth;
                void main() {
                    vec4 color = texture2D(uTex, vUv);
                    float isBG = (1.0 - smoothstep(0.0, 0.05, vDepth)) * smoothstep(2.8, 3.0, color.r + color.g + color.b);
                    float alpha = (1.0 - isBG) * vMask;
                    if (alpha < 0.1) discard;
                    float ps = 0.002;
                    float dR = texture2D(uDepth, vUv + vec2(ps, 0.0)).r;
                    float dD = texture2D(uDepth, vUv + vec2(0.0, ps)).r;
                    if (normalize(vec3((vDepth - dR)*3.0, (vDepth - dD)*3.0, 0.4)).z < 0.2) discard;
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.35);
                }
            `;
            const shadow = new THREE.Mesh(geometry, sMat);
            shadow.position.set(0.15, -0.15, -0.15);
            shadow.scale.set(1, 1, 0.3);
            scene.add(shadow);

            // Mark container has having 3d
            container.classList.add('has-3d');

            canvas.style.display = 'block';
            startAnimate(viewer, mesh, material);

        } catch (e) { console.error("3D Error:", e); }
    }

    function startAnimate(viewer, model, material) {
        let startTime = Date.now();
        let activated = false;
        function frame() {
            if (viewer.isDisposed) return;
            viewer.animateId = requestAnimationFrame(frame);
            const time = Date.now() * 0.0008;
            viewer.scene.rotation.y = Math.sin(time) * 0.08 + (viewer.targetX * 0.05);
            viewer.scene.rotation.x = Math.cos(time * 0.6) * 0.04 - (viewer.targetY * 0.03);
            if (material && material.uniforms.uTime) material.uniforms.uTime.value = time;
            viewer.renderer.render(viewer.scene, viewer.camera);

            if (!activated && (Date.now() - startTime > 2000)) {
                viewer.container.classList.add('has-3d');
                activated = true;
            }
        }
        frame();
    }

    function disposeViewer(container) {
        const viewer = activeViewers.get(container);
        if (!viewer) return;

        viewer.isDisposed = true;
        cancelAnimationFrame(viewer.animateId);
        container.removeEventListener('mousemove', viewer.onMouseMove);
        // Only remove class if we are strictly managing it, but leaving it is fine
        // container.classList.remove('has-3d');

        viewer.scene.traverse(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
                if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                else obj.material.dispose();
            }
        });

        viewer.renderer.dispose();
        activeViewers.delete(container);
    }

    let isInitialized = false;
    function safeInit() {
        if (isInitialized) return;
        isInitialized = true;
        initPerfect3D();
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(safeInit, 10);
    } else {
        window.addEventListener('load', safeInit);
        window.addEventListener('DOMContentLoaded', safeInit);
    }

    function toggleLike(id) {
        fetch(`/like/${id}/`, { method: 'POST', headers: { 'X-CSRFToken': '{{ csrf_token }}' } })
            .then(r => r.json()).then(d => {
                if (d.error) {
                    alert("Debes iniciar sesión para dar me gusta.");
                    return;
                }
                const icon = document.querySelector(`#like-icon-${id}`);
                const count = document.querySelector(`#like-count-${id}`);
                icon.className = d.liked ? 'bi bi-heart-fill liked' : 'bi bi-heart';
                count.innerText = d.count;
            });
    }
</script>
{% endblock %}