{% extends "./layouts/base.html" %}
{% load static %}

{% block title %}Catálogo{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href='{% static "css/home_redesign.css" %}'>
<style>
    .feed-container {
        max-width: 600px;
        margin: 0 auto;
        padding: 20px;
    }

    @media (max-width: 480px) {
        .feed-container {
            padding: 10px;
            /* Minimize padding on mobile */
            width: 100%;
        }

        .feed-card {
            border-radius: 0;
            /* Full bleed on very small screens? or just small radius */
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            /* Lighter shadow */
        }

        .feed-header-actions {
            justify-content: center;
            /* Center button on mobile */
        }
    }

    .feed-header-actions {
        display: flex;
        justify-content: flex-end;
        margin-bottom: 25px;
    }

    .btn-create-post {
        background: #111;
        color: #fff;
        padding: 12px 24px;
        border-radius: 6px;
        text-decoration: none;
        text-transform: uppercase;
        font-size: 0.8rem;
        font-weight: 800;
        display: inline-flex;
        align-items: center;
        gap: 10px;
        border: 1px solid #111;
        transition: 0.25s;
    }

    .btn-create-post:hover {
        background: transparent;
        color: #111;
        transform: translateY(-2px);
    }

    .feed-card {
        background: #fff;
        border: 1px solid #eee;
        margin-bottom: 60px;
        box-shadow: 0 15px 45px rgba(0, 0, 0, 0.07);
        border-radius: 8px;
        position: relative;
        overflow: hidden;
    }

    .feed-card-header {
        padding: 15px 20px;
        display: flex;
        align-items: center;
        border-bottom: 1px solid #f8f8f8;
    }

    .feed-avatar {
        width: 38px;
        height: 38px;
        border-radius: 50%;
        background: #111 url('{% static "images/logo/logo_v2.png" %}') center/cover;
        margin-right: 15px;
        border: 1px solid #eee;
    }

    .feed-username {
        font-weight: 700;
        font-size: 0.95rem;
        color: #111;
    }

    .dropdown {
        position: relative;
        margin-left: auto;
    }

    .dropdown-content {
        display: none;
        position: absolute;
        right: 0;
        top: 30px;
        background: #fff;
        min-width: 140px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        z-index: 100;
        border-radius: 6px;
    }

    .dropdown-content a {
        color: #333;
        padding: 12px 18px;
        text-decoration: none;
        display: block;
        font-size: 0.9rem;
    }

    .dropdown-content a:hover {
        background: #f5f5f5;
    }

    .dropdown:hover .dropdown-content {
        display: block;
    }

    .feed-image-container {
        width: 100%;
        aspect-ratio: 1/1;
        background: #f9f9f9;
        position: relative;
        overflow: hidden;
        cursor: zoom-in;
    }

    .has-3d .feed-image {
        opacity: 0;
        pointer-events: none;
    }

    .feed-image {
        transition: opacity 0.5s ease;
        width: 100%;
        height: 100%;
        object-fit: contain;
        /* Better fit for all formats */
        transition: opacity 0.5s;
    }

    .depth-3d-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: none;
        z-index: 5;
        /* Allow clicks to pass through to image (e.g. for zooming) */
        pointer-events: none;
        /* Allow vertical scrolling on mobile even if touching canvas */
        touch-action: pan-y;
    }

    .has-3d .depth-3d-canvas {
        display: block;
    }

    .manga-3d-badge {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        padding: 6px 14px;
        border-radius: 30px;
        font-size: 0.65rem;
        font-weight: 900;
        z-index: 10;
        border: 1px solid rgba(255, 255, 255, 0.2);
        pointer-events: none;
        backdrop-filter: blur(8px);
    }

    .manga-size-badge {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background: rgba(255, 255, 255, 0.9);
        color: #000;
        padding: 4px 10px;
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: 800;
        z-index: 10;
        border: 1px solid rgba(0, 0, 0, 0.1);
        pointer-events: none;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        text-transform: uppercase;
    }

    .feed-actions {
        padding: 18px 20px;
        display: flex;
        gap: 24px;
        font-size: 1.6rem;
        color: #1a1a1a;
        /* Ensure it's above any 3D canvas overflow */
        position: relative;
        z-index: 50;
    }

    .action-btn {
        background: none;
        border: none;
        cursor: pointer;
        color: inherit;
        transition: 0.2s;
        /* Remove tap delay on mobile */
        touch-action: manipulation;
    }

    .liked {
        color: #ff3040 !important;
    }

    .feed-caption {
        padding: 0 20px 20px 20px;
        font-size: 1rem;
        line-height: 1.5;
    }

    .price-tag {
        color: #bfa37c;
        font-weight: 900;
        float: right;
        font-size: 1.2rem;
    }

    .comment-form {
        display: flex;
        padding: 15px 20px;
        border-top: 1px solid #f5f5f5;
        background: #fafafa;
    }

    .comment-form input {
        flex: 1;
        border: 1px solid #e0e0e0;
        padding: 10px 15px;
        border-radius: 30px;
        margin-right: 12px;
        font-size: 0.9rem;
    }

    .comment-form button {
        border: none;
        background: none;
        color: #0095f6;
        font-weight: 800;
        cursor: pointer;
    }

    /* Zoom Modal Styles */
    #zoom-modal {
        display: none;
        position: fixed;
        z-index: 9999;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        align-items: center;
        justify-content: center;
        cursor: zoom-out;
    }

    #zoom-modal img {
        max-width: 90%;
        max-height: 90%;
        box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        border-radius: 4px;
        transform: scale(0.9);
        transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    #zoom-modal.active {
        display: flex;
    }

    #zoom-modal.active img {
        transform: scale(1);
    }
</style>
{% endblock %}

{% block content %}
<div class="concept-container">
    <div class="concept-hero" style="min-height: 25vh; padding-top: 140px; margin-bottom: 40px;">
        <h1 style="font-size: 5rem; letter-spacing: -3px; margin:0;">CATÁLOGO</h1>
    </div>

    <div class="feed-container">
        {% if user.is_superuser %}
        <div class="feed-header-actions">
            <a href="{% url 'create_post' %}" class="btn-create-post"><i class="bi bi-plus-circle"></i> NUEVA
                PUBLICACIÓN</a>
        </div>
        {% endif %}

        {% for manga in recent_mangas %}
        <div class="feed-card" id="manga-{{ manga.id }}">
            <div class="feed-card-header">
                <div class="feed-avatar"></div>
                <div class="feed-username">{% if manga.publicado_por %}{{ manga.publicado_por }}{% else %}Surchaing
                    Manga{% endif %}</div>
                {% if user.is_superuser %}
                <div class="dropdown">
                    <div style="cursor: pointer; padding: 5px;"><i class="bi bi-three-dots-vertical"></i></div>
                    <div class="dropdown-content">
                        <a href="{% url 'vendido_toggle' manga_id=manga.id %}">
                            {% if manga.vendido %}Marcar Disponible{% else %}Marcar Vendido{% endif %}
                        </a>
                        <a href="{% url 'delete_post' manga.id %}" style="color:#f00">Eliminar</a>
                    </div>
                </div>
                {% endif %}
            </div>

            <div class="feed-image-container"
                data-front="{% if manga.front_page %}{{ manga.front_page.url }}{% endif %}"
                data-depth="{% if manga.depth_map %}{{ manga.depth_map.url }}{% endif %}"
                data-mesh="{% if manga.mesh_3d %}{{ manga.mesh_3d.url }}{% endif %}" data-manga-id="{{ manga.id }}"
                onclick="{% if manga.front_page %}openZoom('{{ manga.front_page.url }}'){% endif %}">

                {% if manga.vendido %}
                <div class="sold-badge"
                    style="position: absolute; top: 10px; right: 10px; background: #ff4d4d; color: #fff; padding: 5px 12px; border-radius: 20px; font-weight: 800; font-size: 0.75rem; z-index: 100; box-shadow: 0 4px 10px rgba(255,77,77,0.4); text-transform: uppercase; letter-spacing: 1px;">
                    VENDIDO</div>
                {% endif %}

                {% if manga.is_3d_converted and manga.front_page and manga.depth_map %}
                <div class="manga-3d-badge"><i class="bi bi-robot"></i> IA 3D ANALYSIS</div>
                <canvas class="depth-3d-canvas"></canvas>
                {% endif %}

                {% if manga.images.count > 0 %}
                <div class="gallery-count-badge"
                    style="position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.6); color: #fff; padding: 2px 8px; border-radius: 4px; font-size: 0.7rem; z-index: 10; display: flex; align-items: center; gap: 4px;">
                    <i class="bi bi-images"></i> +{{ manga.images.count }}
                </div>
                {% endif %}

                {% if manga.talla %}
                <div class="manga-size-badge">Talla: {{ manga.talla }}</div>
                {% endif %}

                {% if manga.front_page %}
                <img src="{{ manga.front_page.url }}" class="feed-image" alt="{{ manga.nombre_del_manga }}">
                {% else %}
                <div class="no-image-placeholder"
                    style="width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:#f5f5f5; color:#ccc;">
                    <div style="text-align: center;">
                        <i class="bi bi-image" style="font-size: 3rem;"></i>
                        <p style="font-size: 0.8rem; margin-top: 5px;">Sin imagen</p>
                    </div>
                </div>
                {% endif %}
            </div>

            <div class="feed-actions">
                <button class="action-btn" onclick="toggleLike('{{ manga.id }}')">
                    <i id="like-icon-{{ manga.id }}"
                        class="bi bi-heart{% if request.user in manga.likes.all %}-fill liked{% endif %}"></i>
                </button>
                <span id="like-count-{{ manga.id }}"
                    style="font-size: 1.1rem; font-weight: bold; margin-left: -15px;">{{ manga.likes.count }}</span>
                <button class="action-btn"><i class="bi bi-chat-left-text"></i></button>
                <button class="action-btn"
                    onclick="shareManga('{{ manga.nombre_del_manga|escapejs }}', '{{ manga.id }}')">
                    <i class="bi bi-share"></i>
                </button>
                <button class="action-btn" style="margin-left: auto;">
                    <i class="bi bi-bookmark"></i>
                </button>
                <div style="margin-left: auto;"><i class="bi bi-bookmark-star"></i></div>
            </div>

            <div class="feed-caption">
                <span class="price-tag">${{ manga.precio }}</span>
                <strong>{{ manga.nombre_del_manga }}</strong>
                <p style="color: #666; margin-top: 5px; margin-bottom: 15px;">
                    {% if manga.descripcion %}{{ manga.descripcion }}{% else %}Surchaing Premium Edition.{% endif %}
                </p>

                <!-- Lista de Comentarios -->
                <div class="feed-comments-list"
                    style="font-size: 0.9rem; border-top: 1px solid #f0f0f0; padding-top: 10px;">
                    {% for comment in manga.comments.all %}
                    <div class="comment-item" style="margin-bottom: 5px;">
                        <strong>{% if comment.user %}{{ comment.user.username }}{% else %}Anónimo{% endif %}:</strong>
                        {{ comment.text }}
                    </div>
                    {% empty %}
                    <p style="color: #999; font-style: italic; font-size: 0.85rem;">Sé el primero en comentar...</p>
                    {% endfor %}
                </div>
            </div>

            <form class="comment-form" action="{% url 'add_comment' manga.id %}" method="post">
                {% csrf_token %}
                <input type="text" name="text" id="comment-input-{{ manga.id }}" placeholder="Añade un comentario..."
                    required>
                <button type="submit">Publicar</button>
            </form>
        </div>
        {% endfor %}
    </div>
</div>

<!-- Zoom Modal -->
<div id="zoom-modal" onclick="closeZoom()">
    <img id="zoom-img" src="" alt="Zoomed View">
</div>

{% endblock %}

{% block extra_js %}
<style>
    /* Loading Pulse Animation */
    @keyframes ai-pulse {
        0% {
            box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4);
        }

        70% {
            box-shadow: 0 0 0 10px rgba(255, 255, 255, 0);
        }

        100% {
            box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
        }
    }

    .ai-loading-active {
        position: relative;
    }

    .ai-loading-active::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 8px;
        animation: ai-pulse 2s infinite;
        pointer-events: none;
        z-index: 10;
    }

    .ai-badge-appear {
        animation: fadeScale 0.5s ease-out forwards;
    }

    @keyframes fadeScale {
        from {
            opacity: 0;
            transform: scale(0.5);
        }

        to {
            opacity: 1;
            transform: scale(1);
        }
    }
</style>

<script type="module">
    // --- SMART WORKER & CACHE LOGIC ---

    // Initialize Worker
    const workerUrl = '{% static "js/depth-worker.js" %}';
    const depthWorker = new Worker(workerUrl, { type: 'module' });

    // Preload model immediately (low priority background)
    depthWorker.postMessage({ action: 'preload' });

    // Handle Worker Responses
    depthWorker.onmessage = (e) => {
        const { status, id, width, height, buffer, error } = e.data;

        if (status === 'preloaded') {
            console.log("Worker: Model Preloaded & Ready.");
            return;
        }

        const container = document.querySelector(`.feed-image-container[data-manga-id="${id}"]`);
        if (!container) return;

        // Remove loading state
        container.classList.remove('ai-loading-active');

        if (status === 'error') {
            console.error("Worker Error:", error);
            // Optional: Show error state
            return;
        }

        if (status === 'success') {
            // 1. Create Canvas from Buffer
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            const imageData = new ImageData(new Uint8ClampedArray(buffer), width, height);
            ctx.putImageData(imageData, 0, 0);

            // 2. Mark as Web AI with Animation
            const badge = document.createElement('div');
            badge.className = 'manga-3d-badge ai-badge-appear';
            badge.innerHTML = '<i class="bi bi-cpu"></i> WEB AI 3D';
            container.appendChild(badge);

            // 3. Add to DOM (hidden) for 3D Viewer to find
            canvas.className = 'depth-3d-canvas';
            canvas.style.display = 'none'; // Viewer will show it
            container.appendChild(canvas);

            // 4. Update Dataset for viewer
            const dataUrl = canvas.toDataURL('image/png');
            container.dataset.depth = dataUrl;

            // 5. CACHE IT!
            try {
                const cacheKey = `depth_cache_${id}`;
                localStorage.setItem(cacheKey, dataUrl);
            } catch (err) {
                console.warn("Storage full", err);
            }

            // 6. Init Viewer immediately
            if (window.initApp3D) window.initApp3D(container);
        }
    };

    // --- SMART LAZY LOADING OBSERVER ---
    // Only triggers AI when the user actually SCROLLS to the image.
    function initSmartAI() {
        const containers = document.querySelectorAll('.feed-image-container');

        const aiObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const container = entry.target;
                    const id = container.dataset.mangaId;
                    const front = container.dataset.front;
                    const depth = container.dataset.depth;

                    // Stop observing this one immediately so we don't trigger twice
                    observer.unobserve(container);

                    // Logic: If needed, generate 3D
                    if (front && (!depth || depth === "")) {

                        // A. Check Cache First (Super Fast)
                        const cacheKey = `depth_cache_${id}`;
                        const cachedDepth = localStorage.getItem(cacheKey);

                        if (cachedDepth) {
                            console.log(`SmartAI: Restored ${id} from Cache.`);
                            container.dataset.depth = cachedDepth;
                            if (window.initApp3D) window.initApp3D(container);
                        }
                        // B. Not in cache? Ask Worker.
                        else {
                            console.log(`SmartAI: Requesting Worker for ${id}`);

                            // Visual Feedback: "Thinking..."
                            container.classList.add('ai-loading-active');
                            container.dataset.id = id; // Ensure ID matches worker expectation

                            depthWorker.postMessage({
                                action: 'generate',
                                imageUrl: front,
                                id: id
                            });
                        }
                    }
                }
            });
        }, {
            rootMargin: '50px', // Trigger slightly before it comes into view
            threshold: 0.1
        });

        containers.forEach(c => aiObserver.observe(c));
    }

    // Initialize on load
    if (document.readyState === 'complete') {
        initSmartAI();
    } else {
        window.addEventListener('load', initSmartAI);
    }

</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script>
    const modal = document.getElementById('zoom-modal');
    const zoomImg = document.getElementById('zoom-img');

    function openZoom(url) {
        zoomImg.src = url;
        modal.classList.add('active');
    }

    function closeZoom() {
        modal.classList.remove('active');
    }

    const activeViewers = new Map();

    function initPerfect3D() {
        const containers = document.querySelectorAll('.feed-image-container');

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    createViewer(entry.target);
                    // Also trigger cache check if entering view? 
                    // Maybe later optimization. 
                } else {
                    disposeViewer(entry.target);
                }
            });
        }, { threshold: 0.05, rootMargin: '200px' });

        containers.forEach(container => {
            observer.observe(container);
        });

        window.addEventListener('resize', () => {
            activeViewers.forEach(viewer => viewer.updateSize());
        });
    }

    // Expose for Worker Callback
    window.initApp3D = (singleContainer) => {
        createViewer(singleContainer);
    };

    function createViewer(container) {
        if (activeViewers.has(container)) return;

        const meshUrl = container.dataset.mesh;
        const frontUrl = container.dataset.front;
        const depthUrl = container.dataset.depth; // Worker sets this now!

        if (!frontUrl || !depthUrl) return; // Wait for Worker/Cache

        // Check again for canvas (client AI might have added it)
        // But with Worker, we rely on dataset.depth DataURL mostly
        // Unless we want to reuse the specific canvas element the worker result created?
        // Actually, loadDisplacement logic below uses TextureLoader.
        // TextureLoader can load DataURLs.
        // So we don't strict need the canvas element if dataset.depth is set.

        let canvas = container.querySelector('.depth-3d-canvas');
        if (!canvas) {
            // Create a canvas for ThreeJS if it doesn't exist (Server-side case)
            // If Worker ran, it appended a canvas, so we use that.
            // If we loaded from cache, we only have DataURL.
            // So we need to create a dedicated canvas for the Renderer.
            canvas = document.createElement('canvas');
            canvas.className = 'depth-3d-canvas';
            container.appendChild(canvas);
        }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(35, 1, 0.1, 1000);
        camera.position.z = 6.5;

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const updateSize = () => {
            const r = container.getBoundingClientRect();
            renderer.setSize(r.width, r.height);
            camera.updateProjectionMatrix();
        };
        updateSize();

        scene.add(new THREE.AmbientLight(0xffffff, 1.0));
        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(2, 2, 5);
        scene.add(light);

        const viewer = {
            renderer, scene, camera, updateSize, container,
            animateId: null, isDisposed: false, targetX: 0, targetY: 0
        };
        activeViewers.set(container, viewer);

        viewer.onMouseMove = (e) => {
            const r = container.getBoundingClientRect();
            viewer.targetX = ((e.clientX - r.left) / r.width) * 2 - 1;
            viewer.targetY = -(((e.clientY - r.top) / r.height) * 2 - 1);
        };
        container.addEventListener('mousemove', viewer.onMouseMove);

        if (meshUrl && meshUrl !== "") {
            const glbLoader = new THREE.GLTFLoader();
            glbLoader.load(meshUrl, (gltf) => {
                if (viewer.isDisposed) return;
                const model = gltf.scene;
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3()).length();
                const center = box.getCenter(new THREE.Vector3());
                model.position.sub(center);
                model.scale.setScalar(2.0 / size);
                scene.add(model);

                canvas.style.display = 'block';
                startAnimate(viewer, model, null);
                container.classList.add('has-3d');

            }, undefined, (err) => {
                console.warn("Fallback displacement", err);
                loadDisplacement(viewer);
            });
        } else {
            loadDisplacement(viewer);
        }
    }

    async function loadDisplacement(viewer) {
        const { container, scene, camera, renderer } = viewer;
        const frontUrl = container.dataset.front;
        const depthUrl = container.dataset.depth;
        const canvas = renderer.domElement;

        if (!frontUrl || !depthUrl || viewer.isDisposed) return;

        const loader = new THREE.TextureLoader();
        loader.crossOrigin = 'Anonymous';

        const loadP = (url) => new Promise((res, rej) => loader.load(url, res, undefined, rej));

        try {
            const [tex, dTex] = await Promise.all([loadP(frontUrl), loadP(depthUrl)]);
            if (viewer.isDisposed) {
                tex.dispose(); dTex.dispose();
                return;
            }

            const geometry = new THREE.PlaneGeometry(2, 2, 128, 128);
            const material = new THREE.ShaderMaterial({
                uniforms: { uTex: { value: tex }, uDepth: { value: dTex }, uTime: { value: 0 } },
                transparent: true, side: THREE.DoubleSide,
                vertexShader: `
                    varying vec2 vUv;
                    varying float vDepth;
                    varying float vMask;
                    uniform sampler2D uDepth;
                    void main() {
                        vUv = uv;
                        float d = texture2D(uDepth, uv).r;
                        vDepth = d;
                        float mask = smoothstep(0.0, 0.02, uv.x) * smoothstep(1.0, 0.98, uv.x) * 
                                     smoothstep(0.0, 0.02, uv.y) * smoothstep(1.0, 0.98, uv.y);
                        vMask = mask;
                        vec3 pos = position;
                        pos.z += d * 1.2 * mask; 
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv;
                    varying float vDepth;
                    varying float vMask;
                    uniform sampler2D uTex;
                    uniform sampler2D uDepth;
                    void main() {
                        vec4 color = texture2D(uTex, vUv);
                        float isBG = (1.0 - smoothstep(0.0, 0.05, vDepth)) * smoothstep(2.8, 3.0, color.r + color.g + color.b);
                        float alpha = (1.0 - isBG) * vMask;
                        if (alpha < 0.1) discard;
                        float ps = 0.002;
                        float dR = texture2D(uDepth, vUv + vec2(ps, 0.0)).r;
                        float dD = texture2D(uDepth, vUv + vec2(0.0, ps)).r;
                        vec3 normal = normalize(vec3((vDepth - dR)*5.0, (vDepth - dD)*5.0, 0.5));
                        if (normal.z < 0.2) discard;
                        vec3 lightDir = normalize(vec3(-0.8, 0.5, 0.8)); 
                        float diff = max(dot(normal, lightDir), 0.0);
                        vec3 final = mix(color.rgb * 0.6, color.rgb * 1.2, diff) * smoothstep(0.0, 0.3, vDepth);
                        gl_FragColor = vec4(final, alpha);
                    }
                `
            });

            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            // Sombra
            const sMat = material.clone();
            sMat.fragmentShader = `
                varying vec2 vUv; varying float vDepth; varying float vMask;
                uniform sampler2D uTex; uniform sampler2D uDepth;
                void main() {
                    vec4 color = texture2D(uTex, vUv);
                    float isBG = (1.0 - smoothstep(0.0, 0.05, vDepth)) * smoothstep(2.8, 3.0, color.r + color.g + color.b);
                    float alpha = (1.0 - isBG) * vMask;
                    if (alpha < 0.1) discard;
                    float ps = 0.002;
                    float dR = texture2D(uDepth, vUv + vec2(ps, 0.0)).r;
                    float dD = texture2D(uDepth, vUv + vec2(0.0, ps)).r;
                    if (normalize(vec3((vDepth - dR)*3.0, (vDepth - dD)*3.0, 0.4)).z < 0.2) discard;
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.35);
                }
            `;
            const shadow = new THREE.Mesh(geometry, sMat);
            shadow.position.set(0.15, -0.15, -0.15);
            shadow.scale.set(1, 1, 0.3);
            scene.add(shadow);

            container.classList.add('has-3d');
            canvas.style.display = 'block';
            startAnimate(viewer, mesh, material);

        } catch (e) { console.error("3D Error:", e); }
    }

    function startAnimate(viewer, model, material) {
        let startTime = Date.now();
        let activated = false;
        function frame() {
            if (viewer.isDisposed) return;
            viewer.animateId = requestAnimationFrame(frame);
            const time = Date.now() * 0.0008;
            viewer.scene.rotation.y = Math.sin(time) * 0.08 + (viewer.targetX * 0.05);
            viewer.scene.rotation.x = Math.cos(time * 0.6) * 0.04 - (viewer.targetY * 0.03);
            if (material && material.uniforms.uTime) material.uniforms.uTime.value = time;
            viewer.renderer.render(viewer.scene, viewer.camera);

            if (!activated && (Date.now() - startTime > 2000)) {
                viewer.container.classList.add('has-3d');
                activated = true;
            }
        }
        frame();
    }

    function disposeViewer(container) {
        const viewer = activeViewers.get(container);
        if (!viewer) return;

        viewer.isDisposed = true;
        cancelAnimationFrame(viewer.animateId);
        container.removeEventListener('mousemove', viewer.onMouseMove);

        viewer.scene.traverse(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) obj.material.dispose();
        });

        viewer.renderer.dispose();
        activeViewers.delete(container);
    }

    let isInitialized = false;
    function safeInit() {
        if (isInitialized) return;
        isInitialized = true;
        initPerfect3D();
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(safeInit, 10);
    } else {
        window.addEventListener('load', safeInit);
        window.addEventListener('DOMContentLoaded', safeInit);
    }

    function toggleLike(id) {
        const icon = document.querySelector(`#like-icon-${id}`);
        // Optimistic UI: Toggle immediately without waiting for server
        const isLiked = icon.classList.contains('liked');

        // Immediate visual feedback
        if (isLiked) {
            icon.className = 'bi bi-heart';
            // Optional: Reduce count locally if you want strictly instant feedback
            // But usually just the heart is enough.
        } else {
            icon.className = 'bi bi-heart-fill liked';
        }

        // Send request in background
        fetch(`/like/${id}/`, { method: 'POST', headers: { 'X-CSRFToken': '{{ csrf_token }}' } })
            .then(r => r.json()).then(d => {
                if (d.error) {
                    alert("Debes iniciar sesión para dar me gusta.");
                    // Revert on error
                    icon.className = isLiked ? 'bi bi-heart-fill liked' : 'bi bi-heart';
                    return;
                }
                // Sync count from server
                const count = document.querySelector(`#like-count-${id}`);
                if (count) count.innerText = d.count;
            }).catch(err => {
                // Revert network error
                icon.className = isLiked ? 'bi bi-heart-fill liked' : 'bi bi-heart';
            });
    }

    function shareManga(title, id) {
        // Construct URL to specific post (or just site root if no hash routing yet)
        const url = `${window.location.origin}/library#manga-${id}`;
        const text = `Check out "${title}" on DERSSG'M!`;

        if (navigator.share) {
            navigator.share({
                title: 'DERSSG\'M Manga',
                text: text,
                url: url,
            })
                .then(() => console.log('Successful share'))
                .catch((error) => console.log('Error sharing', error));
        } else {
            // Fallback for PC
            navigator.clipboard.writeText(`${text} ${url}`).then(() => {
                alert("Enlace copiado al portapapeles!");
            });
        }
    }
</script>
{% endblock %}